# panic的三种情况

1. 关闭已经关闭的channel
2. 关闭未初始化的channel
3. 向已经关闭的channel写入数据


# 阻塞总结
1. 无缓冲管道
    1. 数据要发送，没有接收者
    2. 数据要接受，没有发送者
2. 有缓冲管道
    1. 数据要发送，没有接收者
    2. 数据要接受，没有发送者
    3. channel容量已满，发送者阻塞在写入
    4. channel容量为空，接受者阻塞在读取

# 使用锁还是使用管道
1. 使用锁的场景
   1. 访问共享数据结构中的存储信息
   2. 保存后端服务中的上下文和状态信息数据
2. 使用管道
   1. 与异步操作的结果进行交互
   2. 分发任务
   3. 传递数据所有权

# 阻塞而产生死锁
* [接受者与发送者没有一一对应，数据发送，没有接收者](deadlock_1.go)
* [接受者与发送者没有一一对应，数据接受，没有发送者](deadlock_2.go)
* [向未初始化nil channel中写入数据，从而导致读nil管道引起死锁](deadlock_3.go)
* [向未初始化nil channel中读取数据，从而导致写nil管道引起死锁](deadlock_4.go)
* [没有发送者，但是还要从管道读取数据，引发阻塞，发生死锁](deadlock_5.go)
* [发送者goroutine已经关闭，接受者goroutine发生阻塞](deadlock_6.go)
* [有缓冲区，但是缓冲区已满，发送数据阻塞，引起死锁](deadlock_7.go)
* [有缓冲区，但是缓冲区为空，读取数据阻塞，引起死锁](deadlock_8.go)
* [读取一个关闭的管道，不会引发死锁，而是返回该类型的0值](deadlock_9.go)


# 管道使用总结

1. 无缓冲管道，接受者与发送者要一一对应，不能放在一个goroutine
2. 如果在一个goroutine中在启动了子goroutine，并通过管道通信，要先启动该子goroutine（可能是发送者或者接受），否则该goroutine会因为没有发送者（发送者）会导致死锁
3. 在发送者处关闭管道，在接受者处做好对管道关闭的判断

# 管道应用场景
* 信号量模式
  * [有缓冲通道的实现](semaphore_1.go)
  * [无缓冲通道的实现](semaphore_2.go)
  * [实现互斥锁](mutex.go)
  * [管道工厂](factory.go)
  * [通道迭代器](iter.go)
  * [生产消费者模式](consumer.go)
* 管道选择器模式
  * [根据管道输入值，输出对应的值](selector.go)
  * [打印素数1](prime_1.go)
  * [打印素数2](prime_2.go)
* 新旧 task & worker模式
  * [使用加锁的方式，实现任务分发，并由worker消费]()
  * [使用管道的方式，实现任务分发，并由worker计算](task2.go)
* 惰性生成器
  * [模拟python yield特性](lazy_generator.go)
  * [工厂函数](build_lazy_evaluator.go)
* 限流
  * [管道](ch_limit.go)
  * [滑动窗口算法]
  * [漏桶算法]
  * [令牌桶算法]
* (C/S)模式
  * [c/s模式](cs.go)